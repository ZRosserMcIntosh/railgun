/**
 * Rail Gun - User Identity Helper
 * 
 * Provides utilities for working with user identity keypairs.
 * The identity public key is used as the user's stable identifier
 * and is what entitlement tokens are bound to.
 * 
 * SECURITY:
 * - Identity private keys NEVER leave the device
 * - User ID is derived from public key (hash) for privacy
 */

import * as sodiumModule from 'libsodium-wrappers';

// Handle both ESM namespace import and CommonJS module.exports
const sodium = (sodiumModule as any).default ?? sodiumModule;

import { getCrypto } from '../crypto';

// ============================================================================
// INITIALIZATION
// ============================================================================

let sodiumReady = false;

async function ensureSodium(): Promise<void> {
  if (!sodiumReady) {
    await sodium.ready;
    sodiumReady = true;
  }
}

// ============================================================================
// IDENTITY KEY MANAGEMENT
// ============================================================================

/**
 * Get the current user's identity public key (base64).
 * This is what entitlement tokens are bound to.
 * 
 * @returns Base64-encoded identity public key
 * @throws If crypto is not initialized
 */
export async function getIdentityPublicKey(): Promise<string> {
  const crypto = getCrypto();
  
  if (!crypto.isInitialized()) {
    throw new Error('Crypto not initialized - cannot get identity key');
  }
  
  return crypto.getIdentityPublicKey();
}

/**
 * Compute a stable user ID from an identity public key.
 * This is a one-way hash that provides some privacy.
 * 
 * @param identityPublicKey - Base64-encoded identity public key
 * @returns Hex-encoded user ID (first 32 chars of hash)
 */
export async function computeUserId(identityPublicKey: string): Promise<string> {
  await ensureSodium();
  
  const publicKeyBytes = sodium.from_base64(identityPublicKey);
  const hash = sodium.crypto_generichash(32, publicKeyBytes);
  
  // Convert to hex and take first 32 chars for readability
  return Array.from(hash)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('')
    .slice(0, 32);
}

/**
 * Get the current user's stable user ID.
 * Convenience function that combines getIdentityPublicKey and computeUserId.
 * 
 * @returns Hex-encoded user ID
 * @throws If crypto is not initialized
 */
export async function getCurrentUserId(): Promise<string> {
  const publicKey = await getIdentityPublicKey();
  return computeUserId(publicKey);
}

/**
 * Compute a human-readable fingerprint from an identity public key.
 * Useful for identity verification between users.
 * 
 * @param identityPublicKey - Base64-encoded identity public key
 * @returns Space-separated groups of hex digits (e.g., "AB12 CD34 ...")
 */
export async function computeFingerprint(identityPublicKey: string): Promise<string> {
  await ensureSodium();
  
  const publicKeyBytes = sodium.from_base64(identityPublicKey);
  const hash = sodium.crypto_generichash(32, publicKeyBytes);
  
  // Format as space-separated 4-char groups
  const hex = Array.from(hash)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('')
    .toUpperCase();
  
  const groups: string[] = [];
  for (let i = 0; i < hex.length; i += 4) {
    groups.push(hex.slice(i, i + 4));
  }
  
  return groups.join(' ');
}

/**
 * Get the current user's fingerprint.
 * 
 * @returns Space-separated fingerprint string
 * @throws If crypto is not initialized
 */
export async function getCurrentFingerprint(): Promise<string> {
  const publicKey = await getIdentityPublicKey();
  return computeFingerprint(publicKey);
}

// ============================================================================
// IDENTITY COMPARISON
// ============================================================================

/**
 * Check if two identity public keys are the same.
 * Uses constant-time comparison to prevent timing attacks.
 * 
 * @param keyA - First identity public key (base64)
 * @param keyB - Second identity public key (base64)
 * @returns true if keys are identical
 */
export async function identitiesMatch(keyA: string, keyB: string): Promise<boolean> {
  await ensureSodium();
  
  try {
    const bytesA = sodium.from_base64(keyA);
    const bytesB = sodium.from_base64(keyB);
    
    if (bytesA.length !== bytesB.length) {
      return false;
    }
    
    return sodium.memcmp(bytesA, bytesB);
  } catch {
    return false;
  }
}

// ============================================================================
// KEY GENERATION (for testing)
// ============================================================================

/**
 * Generate a new Ed25519 identity keypair.
 * 
 * ⚠️ FOR TESTING ONLY
 * In the real app, identity keys are generated by the crypto module.
 * 
 * @returns Object with base64-encoded public and private keys
 */
export async function generateIdentityKeypair(): Promise<{
  publicKey: string;
  privateKey: string;
}> {
  await ensureSodium();
  
  const keypair = sodium.crypto_sign_keypair();
  
  return {
    publicKey: sodium.to_base64(keypair.publicKey),
    privateKey: sodium.to_base64(keypair.privateKey),
  };
}

// ============================================================================
// SIGNING (for verification flows)
// ============================================================================

/**
 * Sign data with an identity private key.
 * 
 * @param data - Data to sign (Uint8Array or string)
 * @param privateKeyBase64 - Identity private key (base64)
 * @returns Base64-encoded signature
 */
export async function signWithIdentity(
  data: Uint8Array | string,
  privateKeyBase64: string
): Promise<string> {
  await ensureSodium();
  
  const dataBytes = typeof data === 'string' 
    ? new TextEncoder().encode(data)
    : data;
  
  const privateKey = sodium.from_base64(privateKeyBase64);
  const signature = sodium.crypto_sign_detached(dataBytes, privateKey);
  
  return sodium.to_base64(signature);
}

/**
 * Verify a signature against an identity public key.
 * 
 * @param data - Original data (Uint8Array or string)
 * @param signatureBase64 - Signature to verify (base64)
 * @param publicKeyBase64 - Identity public key (base64)
 * @returns true if signature is valid
 */
export async function verifyIdentitySignature(
  data: Uint8Array | string,
  signatureBase64: string,
  publicKeyBase64: string
): Promise<boolean> {
  await ensureSodium();
  
  try {
    const dataBytes = typeof data === 'string'
      ? new TextEncoder().encode(data)
      : data;
    
    const signature = sodium.from_base64(signatureBase64);
    const publicKey = sodium.from_base64(publicKeyBase64);
    
    return sodium.crypto_sign_verify_detached(signature, dataBytes, publicKey);
  } catch {
    return false;
  }
}
